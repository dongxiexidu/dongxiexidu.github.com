---
layout: post
title: RunLoop线程保活
date: 2015-08-02
tags: RunLoop
---

### 如何设计一个子线程使其命可以一直不死?


1.自定义一个线程继承自NSThread,重写dealloc方法,这样我们监听线程的是否挂掉
```swift
@interface DXThread : NSThread

@end

- (void)dealloc{
    NSLog(@"%s", __func__);
}
```

2.把自定义的线程,声明为属性,那样不就可以保命了吗?

```swift
#import "DXThread.h"

@interface ViewController ()
@property (strong, nonatomic) DXThread *thread;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.thread = [[DXThread alloc] initWithTarget:self selector:@selector(test) object:nil];
    [self.thread start];
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];
}

// 子线程需要执行的任务
- (void)test{
    NSLog(@"%s %@", __func__, [NSThread currentThread]);
}
```
启动程序,打印如下,发现并没有打印dealloc方法,也就说线程没有挂掉,这样的确是保命了
```Swift
[ViewController test] <DXThread: 0x60000081c100>{number = 3, name = (null)}
```
然后发现点击屏幕,没有任何打印,说明这个线程已经不能做事情了

如何给线程保命?然后还可以让线程处理事情?
```swift
self.thread = [[DXThread alloc] initWithTarget:self selector:@selector(saveThreadLife) object:nil];
[self.thread start];

// 这个方法的目的：线程保活
- (void)saveThreadLife {
    NSLog(@"%s %@", __func__, [NSThread currentThread]);
    
    // 往RunLoop里面添加Source\Timer\Observer
    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];
    [[NSRunLoop currentRunLoop] run];
    
    NSLog(@"%s ----end----", __func__);
}
```
代码如上,
- 1.往RunLoop里面添加Source\Timer\Observer(要创建RunLoop,当然RunLoop不需要显示的创建,获取RunLoop的时候如果发现没有默认会创建)
- 2.执行run方法启动RunLoop

