---
layout: post
title: iOS之block的auto变量
date: 2016-05-04
tags: block
---

## 如下代码,DXPerson是否会销毁(是否会调用dealloc方法)

```swift
@interface DXPerson : NSObject

@property (nonatomic,assign) int age;

@end

@implementation DXPerson

- (void)dealloc{
    NSLog(@"DXPerson -dealloc");
}

@end
```

```swift
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        DXBlock block;
        {
            DXPerson *person = [[DXPerson alloc] init];
            person.age = 20;
            
            block = ^{
                NSLog(@"age = %d", person.age);
            };
            
        }
        NSLog(@"=====");
    }
}
```
答案:不会,因为在ARC环境下,block是`__NSMallocBlock__`类型,block存放在堆空间.**将block赋值给_strong指针时候,会自动copy**,只要block不销毁,他捕获的Objective-C对象的auto变量,那么这个对象就被强指针指着,就不会销毁

## 结论:当block内部访问了对象类型的auto变量时候
1.**如果block是在栈上(ARC环境一般block都会自动copy操作,都是在堆上,MRC下栈上的多),将不会对auto变量产生强引用**
2.如果block被拷贝到堆上,`copy`函数内部会调用`_Block_object_assign`函数,`_Block_object_assign`函数会根据auto变量的修饰符(__strong,__weak,__unsafe_unretained)做出相应的操作,类似于retain(形成强引用,弱引用)

## 问题二:如果上面代码person使用weak来修饰person对象,那么结果又如何?
```swift
DXBlock block;
{
    DXPerson *person = [[DXPerson alloc] init];
    person.age = 20;
    __weak DXPerson *weakPerson = person;
    block = ^{
        NSLog(@"age = %d", weakPerson.age);
    };
    
}
NSLog(@"%@",[block class]); // __NSMallocBlock__
```
答案: 会调用`DXPerson`的 `dealloc`方法,block也无法为这个对象保命

通过转成C++代码思考问题.
## 在使用clang转换OC为C++代码时，可能会遇到以下问题
```swift
cannot create __weak reference in file using manual reference
```

解决方案：支持ARC、指定运行时系统版本，比如
```swift
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m
```

可以看到block定义时候,多了一个使用`__weak`修饰的成员变量`weakPerson`,注意,这里并不age这个变量,而是一个person对象
```swift
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  DXPerson *__weak weakPerson;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, DXPerson *__weak _weakPerson, int flags=0) : weakPerson(_weakPerson) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
```
查看到`__main_block_desc_0`这个结构体,多了两个变量,其中是一个`copy`函数,另外一个是`dispose`函数
```swift
static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} 
__main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
```

查看这个copy函数
```swift
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {
    // `_Block_object_assign`函数会根据auto变量的修饰符(__strong,__weak,__unsafe_unretained)做出相应的操作
    // 类似于retain(形成强引用,弱引用)
    _Block_object_assign((void*)&dst->weakPerson, (void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);
}
```

如果block从堆上移除,会调用block内部的dispose函数,`dispose`函数内部会调用`_Block_object_dispose`函数
`_Block_object_dispose`函数会自动释放引用的`auto`变量（release）

查看这个dispose函数源码
```swift
static void __main_block_dispose_0(struct __main_block_impl_0*src) {
    _Block_object_dispose((void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);
}
```

